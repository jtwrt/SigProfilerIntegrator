from . import vector_utils as vu
from .read import get_signatures_txt_path, read_signatures
import sigProfilerPlotting as SigPlt
import os
import pandas as pd

"""
Module for integration of similar signatures from different extractions into a representative set. 
"""

def get_matrix_path(out_dir:str, context_type:str, project:str, iteration:int) -> str:
    str_ct = "".join([c for c in context_type if not c.isdigit()])
    int_ct = "".join([c for c in context_type if c.isdigit()])
    return os.path.join(
        out_dir,
        str_ct+"_"+int_ct+"_matrix_"+project+"_"+str(iteration)+".csv"
    )

def write_matrix(signatures:dict, matrix_path) -> None:

    signatures = pd.DataFrame(signatures)
    signatures = signatures.set_index(["MutationType"])
    signatures.to_csv(
        path_or_buf=matrix_path,
        sep="\t"
    )

def integrate(
        output_dir:str,
        extractions:list[str],
        context_type:str,
        cos_sim_threshold:float=0.99,
        max_iterations:int=5,
        solutions:list[int|None]|None=None,
        generate_plots:bool=True,
        project="integration",
        plot_args=dict(
            output_path=None,
            percentage=True,
            custom_text_upper=None,
            custom_text_middle=None,
            custom_text_bottom=None,
            savefig_format="pdf",
            volume=None,
            dpi=100,
        )
        ) -> None:
    """
    Description
    ---
    Reads the contents of the output folders of different SigProfilerExtractor runs and
    generates a representative set of mutational signatures.
    Similar signatures are integrated into a single representative signature.
        Calculates the cosine similarity between all signatures and integrates
    those with values of at least the chosen threshold into a representative sequence.
    Generated sequences are iteratively compared with all remaining input signatures
    until no pair of signatures reaches the threshold, or the maximum number of iterations
    is reached.

    Parameters
    ---
    output_dir : str
        Existing directory in which the outputs will be saved.
    extractions : list[str]
        output directories generated by previous SigProfilerExtractor runs
    context_type : str
        Context in which the signatures were extracted in each run.
        Example values: SBS96, SBS1536, DBS76, ID83
    cos_sim_threshold : float
        The cosine similarity of two signatures which must be reached for them to be integrated
        into a representative signature. Value between 0 (least similar) and 1 (most similar)
    max_iter : int = 5
        Maximum number of iterations of integrating signatures.
    solutions : list[int|None] = None
        For each extraction, the ID of the corresponding solution that will be used.
        Solution 1 corresponds to the extraction with 1 signature, 2 with 2 signatures etc.
        The values must be 1 up to including max_signatures (extraction argument).
        If an ID is None, the suggested solution will be used. If "solutions" is None,
        the suggested solution will be used for each extraction.
    generate_plots : bool = True
        If True, a plot containing the generated signatures will be created for each
        iteration if signature integration.
    plot_args : dict
        Arguments to pass to the SigProfilerPlotting module to customize generated plots.
    """

    if solutions is None:
        solutions = [None for _ in extractions]

    signatures = dict()
    mut_type_col = None
    for extraction, solution in zip(extractions, solutions):

        sigs_path =  get_signatures_txt_path(
            extraction_path=extraction,
            context_type=context_type,
            solution=solution
        )

        sigs_df = read_signatures(sigs_path)

        # Normalize input signatures and assign an ID
        for sig in sigs_df:
            if sig == "MutationType":
                if mut_type_col is None:
                    mut_type_col = sigs_df["MutationType"]
                else:
                    if mut_type_col != sigs_df["MutationType"]:
                        raise ValueError("Provided signature text files have different MutationType-columns.")
                continue
            else:
                signatures[len(signatures)] = vu.vector_norm(sigs_df[sig])

    iter_signatures = list()

    # Write input matrix
    signatures["MutationType"] = mut_type_col
    matrix_path = get_matrix_path(
        out_dir=output_dir,
        context_type=context_type,
        project=project,
        iteration=0
    )
    write_matrix(signatures, matrix_path)
    iter_signatures.append(matrix_path)

    # Iteratively combine signatures
    for iter_n in range(1,max_iterations+1):
        sig_keys = set(signatures.keys())
        if "MutationType" in sig_keys:
            sig_keys.remove("MutationType")
        signatures = vu.combine_similar(
            vectors=[signatures[i] for i in sorted(sig_keys)],
            cos_sim_threshold=cos_sim_threshold
        )
        if not any([len(key) > 1 for key in signatures]):
            break

        # convert signatures names
        tmp = dict()
        for sig_key in signatures:
            new_key = ",".join([str(i) for i in sig_key])
            tmp[new_key] = signatures[sig_key]
        signatures = tmp

        # Write signatures to file (matrix format)
        signatures["MutationType"] = mut_type_col
        matrix_path = get_matrix_path(
            out_dir=output_dir,
            context_type=context_type,
            project=project,
            iteration=iter_n
        )
        write_matrix(signatures, matrix_path)
        iter_signatures.append(matrix_path)

        if len(signatures) == 1:
            break

    if not generate_plots is True:
        return

    # Generate plots
    # https://github.com/AlexandrovLab/SigProfilerPlotting
    
    variant_type = "".join([c for c in context_type if not c.isdigit()]) # i.e. SBS / ID / CNV ..
    try:
        plot_func = SigPlt.__dict__["plot"+variant_type]
    except KeyError:
        raise KeyError("SigProfilerPlotting does not contain requested plotting function: "+"plot"+variant_type+"()")

    # Arguments of plotting functions are not consistent!
    #   missing arguments in plotSV and plotCNV

    plot_type = "".join([c for c in context_type if c.isdigit()]) # 96 / 1536 ..
    for iter_n, matrix_path in enumerate(iter_signatures):
        
        plot_func(
            matrix_path=matrix_path,
            output_path=output_dir.removesuffix("/")+"/", # Begin of path of generated plot
            project=project+"_"+str(iter_n),   # Part of plot name
            plot_type=plot_type, # arg missing in plotSV and plotCNV
            percentage=True,
            custom_text_upper=None, # arg missing in plotSV and plotCNV
            custom_text_middle=None, # arg missing in plotSV and plotCNV
            custom_text_bottom=None, # arg missing in plotSV and plotCNV
            savefig_format=plot_args["savefig_format"],
            volume=plot_args["volume"],
            dpi=plot_args["dpi"],
        )        
    return